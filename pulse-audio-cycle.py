#!/usr/bin/env python3
"""Script to quickly switch through (wanted) pulseaudio cards (indirectly sinks)

You can provide a list of tuples to filter for

./pulse-audio-cycle.py -c 'pci-0000_0[459]'
# cycle through filtered; no profle change
Headset1(pci-0000_04) -> Monitor(pci-0000_05) -> Headset2(pci-0000_09) -> [repeat]

./pulse-audio-cycle.py -c '0000_0[459]' -p '0000_05' 'hdmi-stereo-extra.'
# cycle through filtered and set proper profile
Headset1 -> Monitor(set profile) -> Headset2 -> [repeat]

Sink descriptions are not stable; meaning they change if the profile changes.
If you want to use them to filter anyways you can use `--use-sink-description`

Inactive profiles will be skipped unless `--with-unavailable` is provided.

To show all available cards, sinks and profiles use:
./pulse-audio-cycle.py -v --dry --use-sink-description --with-unavailable

Todos:
    * Mark active/default card and profile

Know Issues:
    * Order of switching cannot be adjusted
      Reason: I have no need for it
"""
from sys import stderr
import re
from itertools import cycle, groupby
import logging
from argparse import ArgumentParser
from pulsectl import Pulse


def notify(title, text):
    """Use GTK to send notifications"""
    try:
        import gi
        gi.require_version('Gtk', '3.0')
        gi.require_version('Notify', '0.7')
        from gi.repository import Notify

        Notify.init("pulse-audio-cycle")
        n = Notify.Notification.new(title, text)
        n.show()

    except ModuleNotFoundError:
        print(
            "Sorry, something went wrong with the notification. "
            "Are you using Gtk 3.0?",
            file=stderr,
        )


def sink_for_card(card, pulse):
    """Return first sink that uses the given card otherwise return None"""
    sinks = pulse.sink_list()
    for sink in sinks:
        if sink.card == card.index:
            return sink
    return None


def new_card_and_profile(cards_with_profiles, pulse):
    """Take a list of tuples with card and profiles and pulse connection to
    return next card and profile as tuple

    Returns None for profile if there is no adjustment
    """

    # Get the current card+profile used; this has to be done through the sink
    # since this is what is set as default but the sink is generated by a
    # card+profile combination
    current_default_sink_name = pulse.get_sink_by_name(
        pulse.server_info().default_sink_name)

    current_card_index = current_default_sink_name.card
    current_card_profile_name = pulse.card_info(current_card_index).profile_active.name

    next_card_is_new = False
    new_card, new_profile = None, None
    # for card, profiles in cycle(cards_with_profiles):
    for card, profiles in cards_with_profiles:
        # the last card (and profile) in the loop were the currently active ones
        # => pick this card
        if next_card_is_new:
            new_card = card
            if profiles:
                new_profile = profiles[0]
            break

        if card.index == current_card_index:
            # Since the card is the same, we need to check if the profile needs changing
            # 4 cases:
            # - wanted profiles is empty => next card
            # - current profile is the last wanted => next card
            # - current profile is the wanted, the is a next profile => next profile
            # - current profile in not wanted => this card, first profile
            profile_names = [i.name for i in profiles]
            if not profile_names:
                # take next card since no profile should not be touched (empty)
                next_card_is_new = True
                continue
            elif current_card_profile_name in profile_names:
                if current_card_profile_name == profile_names[-1]:
                    # current profile is the last valid one => next card (+ profile)
                    next_card_is_new = True
                    continue
                else:
                    # pick next available profile
                    new_card = card
                    new_profile_index = profile_names.index(current_card_profile_name) + 1
                    new_profile = profiles[new_profile_index]
                    break

            else:
                # if you are here this means:
                # - there is a profile for this card
                # - but it is not yet selected
                # => take first profile
                new_card = card
                new_profile = profiles[0]
                break

    # pick first card + profile since no current match
    # (possibly a card that was not filtered for)
    if not new_card:
        new_card = cards_with_profiles[0][0]
        # if there are profiles for that card, pick the first
        if cards_with_profiles[0][1]:
            new_profile = cards_with_profiles[0][1][0]

    return new_card, new_profile


def main(args):
    pulse = Pulse("pulse-audio-cycle")

    current_sink = pulse.get_sink_by_name(
        pulse.server_info().default_sink_name)

    current_profile = pulse.card_info(current_sink.card).profile_active

    # card -> holds all profiles and sets the active one
    # sink uses a card+profile combination and is names accordingly

    matching_cards_with_profiles = []
    card_pattern = re.compile(args.card)
    logging.debug(f"card_pattern: {card_pattern}")
    # Get a list of all matching cards
    for card in pulse.card_list():
        # Prepare to also match against sink description
        sink_for_current_card = None
        if args.use_sink_description:
            sink_for_current_card = sink_for_card(card, pulse)

        card_pattern_matched = False
        if re.search(card_pattern, card.name):
            card_pattern_matched = True
            logging.info(f"Card matched: {card.name}")
            if sink_for_current_card:
                logging.info(f"-> Sink Description: {sink_for_current_card.description}")
        elif args.use_sink_description:
            if sink_for_current_card:
                if re.search(card_pattern, sink_for_current_card.description):
                    card_pattern_matched = True
                    logging.info(f"Card matched: {card.name}")
                    logging.info(f"-> Sink Description: {sink_for_current_card.description}")
                    logging.info("-> matched via Sink Description")
        # Ignore cards that are not wanted by the user given pattern
        if not card_pattern_matched:
            continue

        matched_profiles = []
        # Check if we need filter for certain profiles or leave as is
        for profile in card.profile_list:
            # skip unavailable profiles (unless wanted)
            if not profile.available and not args.with_unavailable:
                continue

            # Check every given profile
            for cp_card_pattern, cp_profile_pattern in args.profile:
                cp_card_pattern_matched = False
                if re.search(cp_card_pattern, card.name):
                    cp_card_pattern_matched = True
                elif args.use_sink_description:
                    if sink_for_current_card:
                        if re.search(cp_card_pattern, sink_for_current_card.description):
                            cp_card_pattern_matched = True

                # This cp_profile_pattern does not apply to this card
                if not cp_card_pattern_matched:
                    continue

                if re.search(cp_profile_pattern, profile.name):
                    logging.info(f"  Profile matched: {profile.name} ")
                    matched_profiles.append(profile)

        if not matched_profiles:
            logging.info("  No Profile matched – Keeping profile.")

        # put infos into list
        matching_cards_with_profiles.append((card, matched_profiles))

        # separator betweem cards
        logging.info("")

    new_card, new_profile = new_card_and_profile(matching_cards_with_profiles,
                                                 pulse)

    # change profile if necessary
    if new_profile:
        if args.verbose:
            logging.info(f"New Profile: {new_profile.description}")
        if not args.dry:
            pulse.card_profile_set(new_card, new_profile)
    else:
        if args.verbose:
            logging.info("NO new Profile.")

    # change sink (has to be done always because card profile also changes sink)
    new_sink = sink_for_card(new_card, pulse)
    if args.verbose:
        logging.info(f"New Card: {new_card.name}")
        if args.use_sink_description:
            logging.info(f"-> New Sink: {new_sink.description} ")

    if not args.dry:
        pulse.sink_default_set(new_sink)

    # move all input sinks (apps/X clients) to new output sink
    for input_sink in pulse.sink_input_list():
        if args.verbose:
            logging.info(
                f"  -> Switching {input_sink.proplist['application.name']}")
        if not args.dry:
            pulse.sink_input_move(input_sink.index, new_sink.index)

    # Show notification
    if args.notify:
        details = f"New Sink: {new_sink.description}"
        if new_profile:
            details += f"\nNew Profile: {new_profile.description}"

        notify("Sink Changed", details)


if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument(
        "-n", "--notify",
        action="store_true", default=False,
        help="Use this to notify which Sink and Profile was swiched to",
    )
    parser.add_argument(
        "-p", "--profile",
        nargs=2,
        action="append",
        metavar=("CARD_REGEX", "PROFILE_REGEX"),
        help="With regex_for_card regex_for_profile_the_card_should_get. "
             "Can be provides multiple times – for different card patterns."
    )
    parser.add_argument(
        "-c", "--card",
        default="",
        metavar="CARD_REGEX",
        help="Regex pattern of cards to cylce through. "
             "Use in combination with --profile to set profiles during cycle"
    )
    parser.add_argument(
        "--use-sink-description",
        action="store_true",
        default=False,
        help="Instead of only looking at card names, also match regex against "
             "sink description"
    )
    parser.add_argument(
        "--with-unavailable",
        action="store_true",
        default=False,
        help="Don't skip unavailable profiles (if they match the pattern)."
    )
    parser.add_argument(
        "--dry",
        action="store_true", default=False,
        help="Don't change sinks or profile (Useless without -v)"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="count", default=0,
        help="Print extra details for debugging purposes"
    )

    args = parser.parse_args()

    # manual default for --profile because otherwise default is kept by append
    # https://stackoverflow.com/questions/43660172/why-does-argparse-include-default-value-for-optional-argument-even-when-argument
    if not args.profile:
        args.profile = [["", ""]]

    LOGGING_FORMAT = "%(levelname)s: %(message)s"

    if args.verbose >= 2:
        logging.basicConfig(level=logging.DEBUG, format=LOGGING_FORMAT)
    elif args.verbose == 1 or args.dry:
        logging.basicConfig(level=logging.INFO, format=LOGGING_FORMAT)

    logging.debug(args)
    main(args)
